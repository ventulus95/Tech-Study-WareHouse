# 📇 2장 객체 생성과 파괴

## 

## 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하자.

### 	정적  팩토리 메소드란? 

​		아래와 같은 꼴의 코드

```java
public static Boolean valueOf(boolean b){
		return b? Boolean.TRUE : Boolean.False
}
```

생성자 대신 정적 팩토리 메서드로 했을때의 **장점**

1. **이름 가질 수 있다.**

   생성자로 리턴되는 이 생성자가 어떤 객체를 가지는 지를 판단하기가 어려움.  차라리 팩터리 메서드로 이름을 지정해서 만들어주는 형식으로 하면 좀더 명확하게 어떤 객체를 가지는 메소드인지 명확하게 판단가능.

2. **호출될때마다 인스턴스를 새로 생성하지 않음.** 

   객체를 무의미하게 생성하는걸 방지할 수 있고, 언제 어느 인스턴스를 살릴지 죽일지를 명확하게 관리 가능. 

3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음.**

   구현 클래스를 공개하지 않고도 그 객체를 반환 가능

4. **입력 변수에 따라 매번 다른 클래스의 객체 반환 할 수 있음.**

   변수가 크거나 작거나에 따라서 그에 맞는 정도의 클래스를 선택해서 반환할 수 있음. 예를 들어서 갯수가 65개 미만인 경우에는 RegularEnumSet의 인스턴스를 65개 이상인 경우에는 JumboEnumSet의 인스턴스를 반환.

5. **정적 팩터리 메서드를 작성하는 시점에서는 반환할 객체의 클래스가 존재 하지 않아도됨.**

   이런 유연함 덕분에 서비스 제공자 프레임 워크를 만들어도 됨. 

생성자 대신 정적 팩토리 메서드를 했을때의 **단점**

1. 상속시 생성자가 없어 하위 클래스를 생성 불가.

2. 정적 팩토리 메서드를 프로그래머가 찾기가 어려움 

   ​	이런 오류점에 대해서는 API 문서를 잘 만들고, 널리 알려진 규약에 따라서 함수를 만들어야 하는 것이 선행 되야함.

   ​	ex) from 매개변수를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드



## 아이템 2. 생성자에 매개변수가 많다면, 빌더를 고려해라

대안 1: 점층적 생성자 패턴 (생성자의 매개변수를 한개씩 늘려가면서 생성자를 만들어주는 것.)

​	 결국 매개변수가 많아지면 많아질수록 코드를 작성하기도 빡빡하고 읽기도 어려움.

대안 2: 자바 빈즈 패턴

​	생성자는 없는데, setter나 getter로 그안의 값을 변경하려면, 결국 객체하나 만들기 위해서 여러개의 메소드를 계속 생성해야하는 상태. 심지어 이 메소드를 다 써서, 객체를 완전히 값을 다 채우기 전까지는 일관성도 없어짐.  -> 그래서 이런 **일관성**이 없어서 **불변**으로 만들수도 없음. -> 그러면 또 Thread Safe하게도 만들 수 없음. 추가작업을 따로 해줘야함.

### 이런 대안을 다 해결 할 수 있는 빌더 패턴

빌더는 빈즈 패턴처럼 가독성은 있되, 점층적 생성자처럼 안정성도 겸비. 

빌더는 불변값도 가질 수 있고, 그 메서드를 통해서 "Fluent API" 혹은 "Method Chain" 형식으로 코드를 만들수 있음.

`NutrionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).build();`

와 같이 메소드를 붙혀붙혀 생성가능. **Why?** 이 빌더 세터 메소드들은 결국 빌더 자신을을 리턴하므로 붙혀쓰기 가능. 

결국 이런 모습이 파이썬 스칼라등의 존재하는  **선택적 매개변수**를 흉내 낸 것.  

그리고 이런 빌더 패턴은 계층적으로 설계된 클래스랑 같이 쓰기에 훨씬 좋고, 유연성 덕분에 하나의 빌더로 여러객체를 순회하면서 만들거나 매개변수에 따라 다른 객체를 만들 수도 있음.

단점

생성 비용이 크지는 않지만, 성능에 민감한 경우 문제 가능성 있음. 또한, 점층적 생성자 패턴에 비해서는 장황해서 **매개변수가 4개 이상**일때만 효과적임.

하지만 조금 더 고려를 해보자면, API는 시간이 지날수록 매개변수가 늘어나기때문에, 애초부터 빌더패턴으로 구현하는게 차후에 점층적 생성자 혹은 자바 빈즈 패턴을 통해서 만들 걸 다시 고쳐서 생성하는 것보다 훨씬 유리함. 



## 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

**싱글턴 = 인스턴스를 오직 하나만 생성할 수 있는 클래스**

그러다보니 클래스를 싱글턴으로 만들다보면, 사용하는 클라이언트를 테스트하기가 어려워짐. 

싱글턴 만드는 방식은 대부분 두가지 

1. public static final 필드 방식

```java
public static final Class명 temp = new Class명();
```

2. 정적 팩터리의 메서드 방식

```java
public static Class명 getInstance() {return INSTANCES;}
```

3.  **원소가 하나인 Enum 타입** [!추천!]

```java
public enum Class명 {
  INSTANCE;
  
  public void leaveTheBuilding(){....}
}
```

직렬화와 리플렉션 공격에도 2의 인스턴스를 만들어주는걸 방지.



## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용해라.

유틸리티클래스를 만들기위해서 (정적 메서드와 정적 필드만을 담은 클래스를 만들려고) 억지로 **추상클래스를 만든다해도 Instance화를 막을순 없다.**

그러니까 기본 생성자 앞에 private를 붙혀서 아예 클래스 밖에서 선택할수 없게끔하여 Instance를 만들 수 없게끔 해버린다. 

실제로 이런 경우 상속도 불가능하게 하는 효과도 있다. 

하지만, 오해의 요지가 있으므로 "주석을 달아서" 오해가 없도록 하게하는 편이 좋다.

## 

## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

정적 유틸리티 클래스(예를 들어서, 사전 맞춤법검사기)를 만들때 정적자원을 고정해놓는 방식이  좋지 않다.

이런 사전 맞춤법 검사기를 만들때 사전을 다른 사전을 하게되면 다른 맞춤법검사를 해야한다. 

**즉, 자원이 변경됨에 따라서 동작이 달라지면 애초에 싱글턴, 정적 유틸리티 클래스는 적합하지 않다.**  

하나이상의 자원을 사용그리고 의존하고, 그 자원이 동작에까지 영향을 주는상황이라면, 차라리 의존 객체를 주입 받고 처리하는것이 더 편리함. 

의존 객체 주입 방식: **인스턴스를 생성할때 생성자에 필요한 자원을 넘겨주는 방식**

```java
private final Lexicon dictionary;

public SpellChecker(Lexion Dictionary){
  this.dictionary = Objects.requireNonNull(dictionary);
}
```

이런 패턴을 약간 변형하여 **생성자에 자원 팩터리를 넘겨주는 방식**도 존재함.

여기서 말하는 자원 팩터리는 호출할때마다 특정타입의 인스턴스를 반복적으로 만들어주는 객체도 존재한다.

결론적으로는 이런 의존 객체 주입 방식은 클래스의 유연성, 재사용성, 테스트 용이성을 엄청나게 개선시켜준다.

