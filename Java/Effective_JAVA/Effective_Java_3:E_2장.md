# 📇 2장 객체 생성과 파괴

## 

## 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하자.

### 	정적  팩토리 메소드란? 

​		아래와 같은 꼴의 코드

```java
public static Boolean valueOf(boolean b){
		return b? Boolean.TRUE : Boolean.False
}
```

생성자 대신 정적 팩토리 메서드로 했을때의 **장점**

1. **이름 가질 수 있다.**

   생성자로 리턴되는 이 생성자가 어떤 객체를 가지는 지를 판단하기가 어려움.  차라리 팩터리 메서드로 이름을 지정해서 만들어주는 형식으로 하면 좀더 명확하게 어떤 객체를 가지는 메소드인지 명확하게 판단가능.

2. **호출될때마다 인스턴스를 새로 생성하지 않음.** 

   객체를 무의미하게 생성하는걸 방지할 수 있고, 언제 어느 인스턴스를 살릴지 죽일지를 명확하게 관리 가능. 

3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음.**

   구현 클래스를 공개하지 않고도 그 객체를 반환 가능

4. **입력 변수에 따라 매번 다른 클래스의 객체 반환 할 수 있음.**

   변수가 크거나 작거나에 따라서 그에 맞는 정도의 클래스를 선택해서 반환할 수 있음. 예를 들어서 갯수가 65개 미만인 경우에는 RegularEnumSet의 인스턴스를 65개 이상인 경우에는 JumboEnumSet의 인스턴스를 반환.

5. **정적 팩터리 메서드를 작성하는 시점에서는 반환할 객체의 클래스가 존재 하지 않아도됨.**

   이런 유연함 덕분에 서비스 제공자 프레임 워크를 만들어도 됨. 

생성자 대신 정적 팩토리 메서드를 했을때의 **단점**

1. 상속시 생성자가 없어 하위 클래스를 생성 불가.

2. 정적 팩토리 메서드를 프로그래머가 찾기가 어려움 

   ​	이런 오류점에 대해서는 API 문서를 잘 만들고, 널리 알려진 규약에 따라서 함수를 만들어야 하는 것이 선행 되야함.

   ​	ex) from 매개변수를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드



## 아이템 2. 생성자에 매개변수가 많다면, 빌더를 고려해라

대안 1: 점층적 생성자 패턴 (생성자의 매개변수를 한개씩 늘려가면서 생성자를 만들어주는 것.)

​	 결국 매개변수가 많아지면 많아질수록 코드를 작성하기도 빡빡하고 읽기도 어려움.

대안 2: 자바 빈즈 패턴

​	생성자는 없는데, setter나 getter로 그안의 값을 변경하려면, 결국 객체하나 만들기 위해서 여러개의 메소드를 계속 생성해야하는 상태. 심지어 이 메소드를 다 써서, 객체를 완전히 값을 다 채우기 전까지는 일관성도 없어짐.  -> 그래서 이런 **일관성**이 없어서 **불변**으로 만들수도 없음. -> 그러면 또 Thread Safe하게도 만들 수 없음. 추가작업을 따로 해줘야함.

### 이런 대안을 다 해결 할 수 있는 빌더 패턴

빌더는 빈즈 패턴처럼 가독성은 있되, 점층적 생성자처럼 안정성도 겸비. 

빌더는 불변값도 가질 수 있고, 그 메서드를 통해서 "Fluent API" 혹은 "Method Chain" 형식으로 코드를 만들수 있음.

`NutrionFacts cocaCola = new NutritionFacts.Builder(240, 8).calories(100).build();`

와 같이 메소드를 붙혀붙혀 생성가능. **Why?** 이 빌더 세터 메소드들은 결국 빌더 자신을을 리턴하므로 붙혀쓰기 가능. 

결국 이런 모습이 파이썬 스칼라등의 존재하는  **선택적 매개변수**를 흉내 낸 것.  

그리고 이런 빌더 패턴은 계층적으로 설계된 클래스랑 같이 쓰기에 훨씬 좋고, 유연성 덕분에 하나의 빌더로 여러객체를 순회하면서 만들거나 매개변수에 따라 다른 객체를 만들 수도 있음.

단점

생성 비용이 크지는 않지만, 성능에 민감한 경우 문제 가능성 있음. 또한, 점층적 생성자 패턴에 비해서는 장황해서 **매개변수가 4개 이상**일때만 효과적임.

하지만 조금 더 고려를 해보자면, API는 시간이 지날수록 매개변수가 늘어나기때문에, 애초부터 빌더패턴으로 구현하는게 차후에 점층적 생성자 혹은 자바 빈즈 패턴을 통해서 만들 걸 다시 고쳐서 생성하는 것보다 훨씬 유리함. 



## 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

**싱글턴 = 인스턴스를 오직 하나만 생성할 수 있는 클래스**

그러다보니 클래스를 싱글턴으로 만들다보면, 사용하는 클라이언트를 테스트하기가 어려워짐. 

싱글턴 만드는 방식은 대부분 두가지 

1. public static final 필드 방식

```java
public static final Class명 temp = new Class명();
```

2. 정적 팩터리의 메서드 방식

```java
public static Class명 getInstance() {return INSTANCES;}
```

3.  **원소가 하나인 Enum 타입** [!추천!]

```java
public enum Class명 {
  INSTANCE;
  
  public void leaveTheBuilding(){....}
}
```

직렬화와 리플렉션 공격에도 2의 인스턴스를 만들어주는걸 방지.



## 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용해라.

유틸리티클래스를 만들기위해서 (정적 메서드와 정적 필드만을 담은 클래스를 만들려고) 억지로 **추상클래스를 만든다해도 Instance화를 막을순 없다.**

그러니까 기본 생성자 앞에 private를 붙혀서 아예 클래스 밖에서 선택할수 없게끔하여 Instance를 만들 수 없게끔 해버린다. 

실제로 이런 경우 상속도 불가능하게 하는 효과도 있다. 

하지만, 오해의 요지가 있으므로 "주석을 달아서" 오해가 없도록 하게하는 편이 좋다.

## 

## 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

정적 유틸리티 클래스(예를 들어서, 사전 맞춤법검사기)를 만들때 정적자원을 고정해놓는 방식이  좋지 않다.

이런 사전 맞춤법 검사기를 만들때 사전을 다른 사전을 하게되면 다른 맞춤법검사를 해야한다. 

**즉, 자원이 변경됨에 따라서 동작이 달라지면 애초에 싱글턴, 정적 유틸리티 클래스는 적합하지 않다.**  

하나이상의 자원을 사용그리고 의존하고, 그 자원이 동작에까지 영향을 주는상황이라면, 차라리 의존 객체를 주입 받고 처리하는것이 더 편리함. 

의존 객체 주입 방식: **인스턴스를 생성할때 생성자에 필요한 자원을 넘겨주는 방식**

```java
private final Lexicon dictionary;

public SpellChecker(Lexion Dictionary){
  this.dictionary = Objects.requireNonNull(dictionary);
}
```

이런 패턴을 약간 변형하여 **생성자에 자원 팩터리를 넘겨주는 방식**도 존재함.

여기서 말하는 자원 팩터리는 호출할때마다 특정타입의 인스턴스를 반복적으로 만들어주는 객체도 존재한다.

결론적으로는 이런 의존 객체 주입 방식은 클래스의 유연성, 재사용성, 테스트 용이성을 엄청나게 개선시켜준다.

## 

## 아이템 6. 불필요한 객체 생성을 피해라

생성비용이 비싼 객체의 경우 캐싱해서 재사용하는 것이 좋음.

**성능 개선전**

```java
static boolean isRomanNumberal(String s){
  return s.matches(~~~);
}
```

String.matches를 사용하는 것은 정규표현식에는 유리하지만, 성능면에서는 사용하는 것은 별로 좋지않다. 

차라리 이렇게 사용하는 것보다 그 정규 표현식 자체를 초기화 과정에서 직접생성해두고 매소드 호출시에만 인스턴스를 재사용하는게 훨씬 성능면에서 좋다.

**생능 개선후** <- 최소 6.5배정도 더 빠르다

```java
public class RomanNumberals{
  private static final Pattern ROMAN = Pattern.compile("대충 정규표현식");
  
  static boolean isRomanNumberal(String s){
    return ROMAN.matcher(s).matches();
  }
}
```



AutoBoxing도 불필요한 객체를 만들어내는 한 실제사례중 하나이다. 

오토박싱은 기본타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없에주진 않는다. 

**AutoBoxing에 의한 성능저하 사례**

```java
public static long sum(){
  Long sum = 0L;
  for(int i =0; i<Integer.MAX_VALUE; i++)
    sum +=i;
  return sum;
}
```

이럴경우 Long의 박싱된 기본타입때문에 불필요하게 객체가 너무 많이 생기게된다. 

**그래서 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.**



## 아이템 7. 다 쓴 객체 참조를 해제하라

가비지 컬렉션 언어에서는 의도치 않게 객체를 살려두는 메모리 누수를 찾는 건 매우 까다롭다. 즉, 이것은 몇개의 객체가 매우많은 객체들 자체를 회수를 하지 못하게 할 수도 있고, 잠재적으로는 성능에 악영향이 있을 수도 있다.

이런 다 쓴 객체 참조를 위해서 해법은 **"해당 참조를 다썼을 경우 Null처리(참조 해제) 하는 것이다."**

이런 Null 처리를 통해서, 참조해제를 하면 실수로 사용하려할때 NullpointerException을 던지면서 종료한다. 

Null처리를 일일히 다하는 것은 프로그램을 필요 이상으로 더럽게 만드는 행동이기도 하기때문에, 필요한 경우 혹은 예외적인 경우에만 하는것이 좋다. 

#### 그러면 이 Null처리를 언제하는 것이 좋은가?

**자기 메모리를 직접적으로 관리하는 클래스라면, 프로그래머가 항시 메모리 누수에 주의할 필요가 있다.** 

**캐시 역시 메모리 누수를 만들기때문에 주의 해야한다**

weakHashMap을 만들어서 다쓴 엔트리를 제거하는 방식으로 캐시를 제거하자. 

**리스너 혹은 콜백 역시 메모리 누수를 만드는 주범이다.**

콜백을 등록하고, 해지하는 것을 명확하게 하지 않아서 결국 콜백이 계속 쌓이게 될 수 도 있다. **콜백을 약한 참조로 저장해서 가비지 컬렉터가 가져가게 끔하자.** ex) WeakHashMap



## 아이템 8. finalizer & Cleaner 사용을 피해라.

자바에서의 객체 소멸자는 두개가 있는데, 그중 **Finalizer는 예측할 수도 없고 상황에 따라서 위험성이 있어서 일반적으로는 불필요하다.**

자바 9에서는 Finalizer를 사용자제 (Deprecated)로 만들었고, 그 대안으로 Cleaner를 사용하고 있다만... Cleaner 역시 그렇게 좋지 않다. **Cleaner는 Finalizer보다는 덜 위험하지만, 여전히 예측불가이며, 느리고 일반적으로는 불필요함.**

결과론적으로는 **Finalizer와 Cleaner를 통해서는 재때 실행되어야하는 작업을 절대 할 수 없다.**

**상태를 영구적으로 수정하는 작업에서는 절대 Finalizer 혹은 Cleaner에 의존해서는 안 된다.**

**이 둘은 성능문제에서도 큰문제를 가지고 있다.**

**Finalizer는 finalizer 공격에 노출되서 심각한 보안 문제를 만들 수도 있다.**

**객체 생성을 막기위해서는 Finalizer를 쓰는게 아니라, 예외를 던지는 것만 있어도 충분하다.** 

Final이 아닌 클래스를 finalizer 공격으로부터 방어하려면, 아무일도 하지 않는 finalize메서드를 만든 후 final로 설정하면 더 좋다. 

이 정도로 쓰지 말라하면 도대체 어디쯤에서 쓰는지는 책을 확인하는게 좋다. 

p.43~p.46에 걸쳐서 적혀져있다.

### 그럼 이정도로 쓰지 말라고 했으면 이 대안은 무엇인가?

**AutoCloseable을 구현 그리고 인스턴스를 다쓴 이후에 Close를 통해 호출하는 것.**

각 인스턴스가 각자 닫혔는지를 추적하는 것이 좋은데, Close 메서드에서 이객체가 유효하지 않음을 필드에 기록해서 다른 메서드들이  이 객체를 찾으면. IllegalStateException을 던지게끔 하는게 좋다.



## 아이템 9. try-finally 보다는 try-with-resource를 사용하라

자바 라이브러리에는 Close를 통해 직접 닫아줘야하는 자원이 많음. Ex) InputStream, OutputStream... 등등..

이런 여러가지의 자원들을 try-finally로 처리하기에는 너무 더러워진다. try가 3개...4개가 되고, fianlly도 엄청 늘어나기 때문에 이 finally를 쓰는 방식은 너무 코드를 더렵힐 가능성이 크다는 것.

이런 문제를 해결하기위해서는 try-with-resource를 사용하는 것이 더욱 효과적

### try-with-resource는 뭐 어떤식으로 사용해야하는가?

```java
static void copy(String src, String dst) throws IOException{
  try (InputStream in = new InputStream(src);
      OutputStream out = new FileOutputStream(dst)){
    ~~~
  }
  catch(IOException e){
    ....
  }
}
```

그러니까 단순하게 말하자면 `try(Resource)` Try를 쓸때 괄호안에다가 Resource를 넣어서 스스로 Close되게 처리하는 방식이다. 

만약 두개의 Resource가 있는 경우, ;(세미콜론)으로 구별하면 된다. 심지어 Catch문이랑 함께 사용해도 괜찮다. 

실제로 이런 예외들을 발생할때는 보여줄 예외하나만 보존되고 여러가지 예외는 숨겨질 수도 있는데, 대신 이렇게 숨겨진 예외들도 그냥 버려지지 않고, 스택에 꼬리표를 달고 출력됨. 자바 7버전의 Throwalbe에 getSuppressed메서드를 이용하면, 코드에서 직접 볼수도 있다.

