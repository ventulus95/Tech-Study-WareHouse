# 📇 9장 일반적인 프로그래밍 원칙



## 아이템 57. 지역변수의 범위를 최소화하라

지역변수의 범위를 줄이는 가장 강력한 방법은 **'가장 처음 쓰일때 선언하기'**   

거의 **모든 지역변수는 선언과 동시에 초기화하는 것이 좋다**. 하지만, 정보가 충분하지 않으면 충분할때까지 선언을 미루는 게 좋고, Try-catch절의 경우 Try 윗줄에 선언하는 것을 추천한다.

이런 지역변수는 반복문에서 변수 범위를 최소화 시켜주곤한다. While문을 사용하면, 복사 붙혀넣기의 오류 발생할 수 있다 .그에 따른, 오류 체킹도 잘 안될 수 도 있고, 오히려 다른 것을 오류로 오해 할 수도 있다.

For문을 사용하게 되면, 반복자의 유효범위가 결국 For문의 종료와 함께 사라지기 때문에 복사 붙혀넣기시 컴파일시에 오류를 잡아준다.

두번째로는 변수 유효범위가 For문과 일치해서 똑같은 이름의 변수를 여러 For문에서 써도 문제가 발생하지 않음.

마지막으로, 지역변수를 최소할 수 있는 방법으로 **메서드를 작게 유지하고 한가지 기능에만 집중하는 것**이 좋다.

&nbsp;

## 아이템 58. 전통적인 For문 보다는 For-each문을 사용하라

For문을 사용하는 것은 While문을 사용하는 것보다야는 나은 선택이지만, 그렇다고 최고의 선택은 또 아니다. 

왜냐하면 반복자 혹은 인덱스 변수가 반복적으로 등장하게되어 코드를 모두 지져분하게 만들어지기도하고, 그에 따른 오류가 발생할 수도 있다. 마지막으로 컬렉션이냐 배열에 따라서 달라지기도 하기때문에 주의할 점이 많다.

그래서 For-Each를 사용하게되면 위의 문제를 해결 할수 있다. 

<!--For-each문의 정식명칭은 '향상된 For문이다.(enhanced for Statement)'-->

### For-each문에 대해서

```java
for(Element e : elements){
  ...
}
```

여기서 : (클론)은 IN과 같은 역할을 하고 읽을때도 In으로 읽으면 된다.

더 중첩시의 오류를 줄여줄도 있고 중첩하여 순회시에 오히려 더 명확하게 오류를 줄여준다.

다음은 주사위 두개를 굴렸을때 모든 경우의 수를 출력해야하는 코드이다.

```java
enum Face  {1,2,3,4,5,6}
..
Collection<Face> = faces = EnumSet.allOf(Face.class);

for(Iterator<Face> i = faces.iterator(); i.hasNext();)
  for(Iterator<Face> j = faces.iterator(); j.hasNext();)
    System.out.println(i.next()+" "+j.next());

```

이러면 6가지의 경우만 출력된다. 즉 동시에 순회가 되어 경우는 6개만나오게되는데, 위의 코드를 약간만 수정해보자. (물론 위의 예제와 같은 것은 아니지만, 상위 For문이 아래의 For문을 모두 순회한후에 한칸씩 넘어가는 구조는 동일하다.)

```java
for(Iterator<Suit> i = suits.iterator(); i.hasNext();){
  Suit suit = i.next();
  for(Iterator<Rank> j = Rank,iterator(); j.hasNext();)
    deck.add(new Card(suit, j.next()))
}
```

하지만 이래도 코드 길이 자체는 길어진다. 이런 것을 방지하기위해서는, For each를 사용한다.

```java
for(Suit suit: suits){
  for(Rank rank: ranks){
    deck.add(suit, rank);
  }
}
```

더 효과적이고 직관적으로 어떤식으로 들어가는지 명확해진다.

하지만 이런 For-each문을 사용하지 못하는 예외 상황이 존재한다. 

1. **파괴적인 필터링(destructive Filtering)**: 컬렉션을 순회하면서 선택된 원소를 제거한다면, 반복자의 remove 메서드를 호출해야한다. 자바 8부터는 Collection의 removeIf 메서드를 사용해야 컬랙션을 명시적으로 순회하는 것을 피할 수있다.
2. **변형(Transforming)**: 리스트나 배열을 순회하면서 그원소의 값 일부 혹은 전체를 교체하면 리스트의 반복자 혹은 배열의 인덱스를 사용하는 것이 좋다.
3. **병렬반복(parallel iteration)**: 여러 컬렉션을 병렬로 순회해야한다면, 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야한다.

위의 상황에 속한 경우는 일반적인 For문을 사용해야 한다,

그리고 마지막으로 Iterable 인터페이스를 구현해놓은 객체라면 그 객체가 무엇이 되었든 간에 순회할 수 있으므로, 만들때 Colletion 인터페이스를 만들지 않더라도 고려해보는 것을 추천한다.

&nbsp;

## 아이템 59. 라이브러리를 익히고 사용하라

Random 함수는 사실 정말 무작위한 수보다는 오히려, 편향된 값들을 뽑을 가능성이 더 크다. 그리고 주기적으로 비슷한 값을 출력해 낼수도 있다. 심지어는 내가 원한 범위 밖의 수를 뽑아낼 수 도 있다. 

그러면 어떤식으로 해결해야하는가? 직접 정수론,의사난수 생성기, 2의 보수 계산기등 수학을 더 복잡하고 심도있게 공부해서 만들어야하는가? 그건 아니다.

Random대신 ThreadLocalRandom으로 대처할때 재대로 작동하고, 실제로 효율까지 더 좋다.

**표준 라이브러리를 사용하면 좋은 이점은**

1. **그 코드를 사용한 전문가의 지식과 앞서 사용한 다른 프로그래머의 경험을 그대로 활용할 수 있다.**
2. **핵심적인 일과 크게 관련 없는 문제를 해결하는데 허비하는 시간을 줄일 수 있다는 것.**
3. **따로 노력하지 않아도 지속적으로 성능 개선이 된다는 것이다.**
4. **기능이 점점 많아진다.**
5. **내가 작성한 코드가 많은 사람에게 낯익은 코드가 된다는 것**

메이저 릴리즈시마다 주목할 만한 수많은 기능이 라이브러리에 추가된다. 

전부다 공부하는 것은 너무나도 어려운일이고, 적어도 **java.lang, java.util, java.io** 와 같은 하위 패키지에 대해서는 익숙해지는 것이 좋다.  

일단 표준라이브러리에서 찾아보고 없으면 서드파티 라이브러리 그래도 없으면 직접 구현을 하는 것이 좋다.

> **바퀴를 다시 발명하지 말자.**

&nbsp;

## 아이템 60. 정확한 답이 필요하다면, float와 double은 피해라

**float와 double 타입은 금융 관련 계산과는 맞지 않다.**

금융 계산에서는 BigDecimal 혹은 int, long만을 사용하자. 물론 BigDecimal이 단점이 있다. 

첫번째는 기본타입보다는 느리고 쓰기가 불편하다.

9자리 십진수로 처리가능하다면, int를 18자리로 처리가능하다면 long을 그 이상이라면  BigDecimal로 사용하기를 추천한다.

&nbsp;

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하자

자바의 데이터 타입은 크게 두가지이다. int, double,boolean 같은 기본 타입. String,List 같은 참조 타입. 그리고 기본 타입에 대응하는 참조타입이 하나씩 존재함. Integer, Double Boolean 과 같이 참조 타입이 존재한다.

오토 박싱과 오토언박싱때문에 두타입을 크게 구별하지 않아도, 사용할 수 있어도 차이가 없는 것은 아니다. 

기본 타입과 참조 타입의 차이는 크게 세가지이다. 

1. 첫번째는 기본 타입은 값만 가지고 있으나 박싱된 기본 타입은 값+ 식별성(indentity) 속성을 가진다. 그래서 값이 같더라도 이 식별성 때문에 값을 다르다고 볼 수 있다.
2. 두번째는 기본 타입의 값은 언제나 유효하지만, 참조타입은 값이 유효하지 않은 Null값을 가질 수 있다.
3. 세번째는 기본타입이 박싱된 기본타입 보다 시간 메모리면에서 훨씬 여유롭다.

같은 객체를 비교하는 경우가 아니라면, 박싱된 기본타입에 == 연산자를 사용하는 것은 오류를 발생 시킨다. 만약 박싱된 타입을 그대로 사용하면서 비교하기위해서는 기본 타입 정수로 저장하고 비교를 기본 타입 변수로 비교해야한다. 

또한 기본 타입(int)과 박싱된 기본 타입(Integer)을 혼용한 연산에서는 **박싱된 기본타입의  박싱이 자동적으로 풀린다**. 여기에 Null참조까지 더해진다면 NullpointException까지 발생한다. 

위의 경우는 오토박싱과 언박싱이 계속적으로 발생해서 성능에 큰 영향을 미친다. 

&nbsp;

### 그러면 박싱된 기본 타입을 언제 사용해야하는가?

**컬렉션의 원소, 키, 값을 으로 사용한다.**  컬렉션은 기본 타입을 담을 수 없어 박싱된 기본 타입을 사용해야한다. 

더 일반화해서 이야기하자면, **매개변수 타입**이나, **매개변수화 메서드의 타입 매개변수**로는 박싱된 것을 사용해야한다.

**리플렉션을 통한 메서드를 호출**할때도 박싱된 기본 타입을 사용해야한다.

&nbsp;

## 아이템 62. 다른 타입이 적절하다면 문자열 피하라

String자체는 텍스트를 표현하도록 잘 설계가 되있지만, 쓰이지 않아야할 곳에서도 쓰이고 있다.

**문자열은 다른 값 타입을 대신하기에는 적합하지는 않다.** 즉, 열거타입 혼합타입을 대신하기에는 적합하지 않다. 이들은 상수, 혼합 데이터를 처리하는데 있어서 강점이 없다.

**문자열은 권한을 표현하기에는 적합지 않다.** 예를들어 Thread의 지역변수 기능을 설계할때 String으로 설계하면 의도치 않게 전역 이름 공간에서 공유되고 의도치 않게 같은 키를 쓰기로 결정하면 변수를 공유하고 두개의 클라이언트를 제대로 사용하지 못한다는 것이다.

이런식으로 사용하는 것이 아닌, 위조 불가능 한 키 즉, Class를 생성해서 권한키(Capacity)를 만들어서 사용하면 된다.

&nbsp;

## 아이템 63. 문자열 연결은 느리니 주의 하자.

String을 String끼리 붙이는 것은 아주 아주 좋지 않은 생각이다. 문자열 연결연사자로 문자열 N개를 잇는 시간은  
$$
N^2
$$
에 비례한다. 

그러니까 이러지말고, **StringBuilder를 활용해서 Append**로 붙혀서 처리하는 것이 더욱 속도가 빠르다.

&nbsp;

## 아이템 64. 객체는 인터페이스를 사용해 참조하라.

적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.

```java
Set<Son> sonset = new LinkedHashSet<>(); // 인터페이스를 타입으로 사용했다. 좋은 예
LinkedHashSet<Son> sonset = new LinkedHashSet<>(); // 클래스를 타입으로 사용했다. 나쁜예
```

**인터페이스를 타입으로 사용하는 습관을 길러두면 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.**

왜 그러나면은 다음과 같은 상황에서 되게 유용하기 때문이다.

```java
Set<Son> sonset = new HashSet<>(); // linkedhashset을  Hashset으로 바꿔도 오류가 안난다.
```

단, 한가지 주의 사항이 있다. 원래의 클래스가 인터페이스의 일반 규약이외의 특별한 기능을 제공하며, 주변코드가 이기능에 기대어서 동작면, 클래스도 반드시 같은 기능을 제공해야한다는 것이다.  

예를 들어서 linkedhashset의 순서 정책을 가정하고 코드를 만들었어도, 그걸 hashset으로 바꿔서 적용하려면 오류가 발생한다.

**물론, 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.**

그런 케이스는 여러가지가 있는데 

1. String, Integer와 같은 값클래스
2. 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이다.
3. 인터페이스에는 없는 특별한 메서드를 제공하는 클래스들 ex) priorityQueue클래스 queue에는 없는 comparator를 제공한다.

적합한 인터페이스가 없으면 클래스의 계층구조 중 가장 필요한 기능 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.

&nbsp;

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

리플렉션기능( java.lang.reflect)을 이용하면, 프로그램에서 임의의 클래스에 접근할 수 있다. Class 객체가 주어지면 그클래스의 생성자,메서드,필드에 해당하는 Constructor Method,Field 인스턴스를 가져올 수 있고, 이어서 이 인스턴스들로는 그 클래스의 맴버 이름, 필드 타입, 메서드 시그니처를 가져올 수 있다.

물론 장점도 있지만, 그만큼의 단점도 존재한다.

- 컴파일타임 타입검사가 주는 이점을 하나도 누릴 수 없다.
- 리플랙션을 이용하면 코드가 지저분해지고 장황해진다.
- 성능도 떨어진다.

리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다.

**리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.**

&nbsp;

## 아이템 66. 네이티브 메서드는 신중히 사용하라

자바 네이티브 인터페이스(java Native Inteface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다. 여기서 네이티브 메서드란 C or C++과 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.

이런 네이티브 메서드를 주요쓰임은 총 3가지이다.

1. 레지스트리 같은 플렛폼 특화 기능을 사용한다.
2. 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 레거시 라이브러리가 그예시
3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.

**성능 개선할 목적으로 네이티브 메서드를 사용하는 건 별로 권장하지 않는다.**

이미 java성능이 예전에 비해서 많이 다른 언어와 비교할정도로 올라왔고, 심각한 단점도 존재하기때문이다.

네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리훼손 오류로 부터 안전하지 않다.

&nbsp;

## 아이템 67. 최적화는 신중히 하라.

최적화 격언을 읽어보면 결론은 결국 안하는 게 더 최적화를 하는 방법이라고 한다.

-  **"빠른 프로그램보다는 좋은 프로그램을 작성하라."**  

  물론 성능 문제 자체를 무시하라는 뜻은 아니지만, 구현상의 문제는 최적화해서 해결할 수 있지만 결함이 생긴게 성능을 제한하면 애초에 다시 싹갈아엎고 만들어야하므로, 설계단계에서부터 성능을 염두해놓고 만들어야한다.

- **성능을 제한하는 설계를 피하라**

  완성후 변경하기 어려운 요소들은 컴포넌트, 외부 시스템과의 소통방식이다. 이런건 만들고 나면 바꿀때마다 큰 문제점이 생길수 있어  주의 해야한다.

- **API를 설계할때 성능에 주는 영향을 고려하라.** **성능을 위해서 API를 왜곡하는 건 매우 안좋은 생각이다.**

- **각각의 최적화 시도 전후로 성능을 측정하라**

  최적화는 굳이 안하는 것을 격언에서도 추천했지만 그 격언에 하나를 추가하자면 위의 아티클이다. 

&nbsp;

## 아이템 68. 일반적으로 통용되는 명명 규칙을 사용하라.

자바플랫폼은 명명규칙이 잘 정립되어있다. 그래서 철자 규칙을 잘따라야한다

&nbsp;

**패키지와 모듈이름**

​	각 요소를 .(점) 으로 구별하여 계층적으로 짓는다. 요소들은 모두 소문자 알파벳 혹은 숫자로 이뤄진다.

​	패키지의 경우라면, 인터넷 도메인 이름을 역순으로 이용한다. 패키지의 이름은 나머지 해당 패키지를 설명하는 하나 이상의 요소로 이뤄서 만들어야하며 8자 이하의 짧은 단어를 추천한다.

&nbsp;

**클래스와 인터페이스의 이름** 

​	하나의 이상 단어로 이뤄지고 각 단어의 문자는 대문자로 시작한다. 여러 단어의 첫글자만 딴 약자(min,max)를 제외하고는 단어를 안줄이는 것을 추천한다.

&nbsp;

**메서드 필드이름**

​	첫글자를 소문자로 쓰는 것만 빼면 클래스 명명 규칙과 같다.

&nbsp;

**상수 필드이름**

​	모든 문자를 대문자로쓰고 단어와 단어사이를 밑줄로 구분한다. 상수필드란 static final이 붙은 필드 즉, 불변인 필드를 뜻한다.

&nbsp;

**지역 변수**

​	다른 맴버와 비슷한 명명 규칙을 써도 되지만, 약어를 사용한다. 입력 매개변수는 일반지역변수보다는 구체적으로 써야한다.

&nbsp;

**타입매개변수**

​	보통 한무자로 표시한다. 임의의 타입 T, 컬렉션 원소는 E, 맵의 키 벨류는 K, V. 예외는 X, 메서드 변환타입에는 R



아래는 위의 내용을 표로 정리한 것이다.

| 식별자 타입         | 예시                                             |
| ------------------- | ------------------------------------------------ |
| 패키지와 모듈       | org.junit.jupiter.api, com.google.common.collect |
| 클래스와 인터페이스 | Stream, FutureTask, LinkedHashMap, HttpClient    |
| 메서드와 필드       | remove, groupingBy                               |
| 상수필드            | MIN_VALUES, NEGATIVE_INFINITY                    |
| 지역변수            | i,denom, houseNum                                |
| 타입 매개변수       | T,E,K,X,R,U,V,T1,T2                              |

&nbsp;

### 문법 규칙

문법 규칙은 철자 규칙보다는 유연하게 작동한다.

객체 생성 가능 클래스는 단수명사나 명사구 사용하고 객체 생성 불가능 클래스는 복수명사로 처리한다. 

인터페이스 이름은 클래스와 동일하게 짓거나 able ible를 붙혀서 형숑사로 짓는다. 

에너테이션은 워낙다양해서 지배적 규칙이 없이 두루두루 사용한다.

동작을 수행하는 메서드의 이름은 동사구로 짓는다. Boolean을 반환하는 메서드는 is혹은 has와 같은 명사,명사구, 형용사로 가능한 단어 혹으 구로 짓는다. ex) isEmpty

해당속성을 반환하는 메서드는 get으로 시작하는 형태로만 써야한다.

특별한 메서드이름이 존재 

객체의 타입을 바꿔서 다른 타입의 또다른 객체를 반환하는 메서드 이름은 보통 ToType명으로 짓는다. (toString, toArray 생각하면 쉽다.)

객체 내용을 다른 뷰로 보여주는 메서드의 이름은 asType명 형태로 짓는다. (asList처럼.)

객체의 값을 기본 타입으로 값 반환하는 메서드의 이름은 보통 type명Value형태로 이름을 짓는다.  (intValue)

마지막으로 정적 팩터리의 이름은 다양하지만, from of valueOf, instance, newInstance, getType, newType을 사용한다.

필드 이름의 관한 뮤법규칙은 덜명확하고 덜중요하다. 

